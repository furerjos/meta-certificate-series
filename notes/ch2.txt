# Chapter 2 – Programming with JavaScript

## Introduction to JavaScript

- JavaScript is a versatile, high-level programming language primarily used for web development.
- You can style console output in the browser using `%c` in `console.log`. For example:
  ```js
  console.log("%cHello, World", "color: blue; font-size: 40px");
  ```
  The `%c` placeholder applies the provided CSS styles to the text.

## Data Types

JavaScript has **7 primitive data types**:
- `string`
- `number`
- `boolean`
- `null`
- `undefined`
- `symbol`
- `bigint`

> **Note:** `BigInt` and `Symbol` were added in later versions of JavaScript.

## Brief History of JavaScript

- Created in just 10 days in 1995 by Brendan Eich for Netscape Navigator 2.
- Originally named **LiveScript**, but renamed to **JavaScript** to capitalize on Java's popularity (despite being unrelated).
- In 1997, Netscape worked with ECMA (European Computer Manufacturers Association) to standardize the language, resulting in the first edition of the **ECMAScript** specification (ECMA-262).
- The ECMAScript standard has been updated many times since 1997.
- JavaScript code runs on a **JavaScript engine** (e.g., V8 in Chrome, SpiderMonkey in Firefox).
- JavaScript interacts with browsers via **Browser APIs** (e.g., DOM, Fetch API).
- In 2009, **Node.js** (created by Ryan Dahl) enabled JavaScript to run outside the browser, allowing server-side and command-line applications.

## Switch Statement Syntax

```js
switch (expression) {
  case value1:
    // code to execute if expression === value1
    break;
  case value2:
    // code to execute if expression === value2
    break;
  case value3:
    // code to execute if expression === value3
    break;
  default:
    // code to execute if no cases match
    break;
}
```

## Building Blocks of a Program

### Functions

```js
function functionName() {
    // body
}

// calling function
functionName();
```

### Arrays

```js
var arrayName = ["item1", "item2", "etc"];
// Accessing elements: arrayName[0], arrayName[1], arrayName[2]
```

### Objects

- Groups of data

```js
var objectName = {
    k: v,
    k2: v2,
    trait: value,
    key: value
}

// Adding properties
object.k = "new assignment";
object.method1 = function() {
    // code here
}
```

**Object literal syntax:**
```js
var obj = {};
// Can use dot notation to add new properties to object:
obj.newTrait = 1;
obj[0] == obj["newTrait"] == 1
```

> **Note:** Arrays are objects. They have built-in properties and methods such as `push()` (adds) and `pop()` (removes last item from array).

## Math Object Cheat Sheet

### Constants
- `Math.PI`
- `Math.E`
- `Math.LN2`

### Rounding Methods
- `Math.ceil()`
- `Math.floor()`
- `Math.round()`
- `Math.trunc()` - removes decimal, keeps integer

### Mathematical Operations
- `Math.pow(2,3)` → number 2 to the power of 3 = 8
- `Math.sqrt(16)` → 4
- `Math.cbrt(8)` → 2
- `Math.abs(-5)` → 5
- `Math.log(x)`, `Math.log2(x)`, `Math.log10(x)`
- `Math.random()` → generates number between 0 and 0.99

```js
var decimal = Math.random();
```

## String Methods Cheat Sheet

- `.length`
- `.charAt()`
- `.concat('')`
- `.indexOf('specified char')` and `.lastIndexOf()`
- `.split('split char')` - ex: `"ho-ho-ho".split("-")` → `['ho', 'ho', 'ho']`
- `.toLowerCase()`
- `.toUpperCase()`

## TypeOf Operator

```js
var test = typeof('What is this');
console.log(test); // "string"
```

## Error Handling

### Error Object Properties
Error objects have `name`, `message`, and `stack` properties:

```js
try {
    let a = b; // ReferenceError
} catch (error) {
    console.log(error.name);
    console.log(error.message);
    console.log(error.stack);
}
```

### Best Practices for Handling Errors

1. **Use Try-Catch Blocks:** To handle predictable runtime errors gracefully
2. **Validate Inputs:** Helps prevent invalid operations by checking inputs
3. **Use Specific Error Types:** Throw custom errors where necessary, for clarity

## Null, Undefined, and Empty Values

### `undefined`
- **What it is:** A primitive value that indicates a variable has been declared but not assigned a value
- **Type:** `"undefined"`
- **When it occurs:**
  - Variable declared but not initialized
  - Function parameter not provided
  - Object property that doesn't exist
  - Function with no return statement

### `null`
- **What it is:** A primitive value that represents the intentional absence of any object value
- **Type:** `"object"` (this is a JavaScript quirk!)
- **When it occurs:** Explicitly set by the programmer to indicate "no value"

### Empty Values
- **What they are:** Values that exist but contain no meaningful content
- **Examples:** `""`, `[]`, `{}`, `0`

## Programming Paradigms

Paradigms are styles of coding:

- **Functional Programming (FP):** Functionality and data are separated, data is only passed into functions when needed to compute something.
- **Object Oriented Programming (OOP):** Data and functionality are grouped as properties and methods inside objects.
- **First-class functions:** Functions in JS are "first-class citizens", meaning functions in JS are another value that we can pass to other functions, save in variables, and return from other functions. Functions are essentially values.

### Example: First-class Functions

```js
function addTwoNums(a, b) {
    console.log(a + b);
}

function randomNum() {
    return Math.floor((Math.random() * 10) + 1);
}

function specificNum() { 
    return 42; 
}

var useRandom = true;
var getNumber;

if(useRandom) {
    getNumber = randomNum;
} else {
    getNumber = specificNum;
}

addTwoNums(getNumber(), getNumber());
```

- **Pure vs Impure Functions: **Pure functions return the same result with the same values everytime, impure functions like Math.random() return different calues each time it is called.

### Benefits of OOP

- Modular code, flexible, and reusable

class Animal { /*Class code here */ }
var myDog = Object.create(Animal)
or...
var myDog = new Animal()

Principles - Inheritance, Polymorphism, Abstraction, Encapsulation

Inheritance: 
- There is a base class of something, that may have subclasses that inherit properties from the base class, and those subclasses can have their own subclasses. This concept in inheritance.
continuing the Animal example:
class Animal { ... }
class Mammal extends Animal { ... }
class Elephant extends Mammal { ... }

Encapsulation:
- Simply put, encapsulation has to do with making a code implementation "hidden" from other users, you don't need to know how the code works to use it. Think of when you use a library, you don't see the underlying funtionality when you call on a method. 
"abc".toUpperCase(); <- I don't need to know how toUpperCase() is made to use it

Abstraction:
- All about writing code in a generalized way. Extracting the CONCEPT of what you're trying to do, rather than dealing with a specific instance or manifestation of said concept. 
- I like to think of interfaces and classes as a good example to explain abstraction and inheritance. 

Polymorphism:
- Multiple forms, things can change value. 

Super: Grabs methods from parent
ex:
class Bird {
    useWings() {
        console.log("Flying!");
    }
}
class Eagle extends Bird {
    useWings() {
        super.useWings();
        console.log("Barely flapping!");
    }
}
class Penguin extends Bird {
    useWings() {
        console.log("Diving!");
    }
}
var baldEagle = new Eagle();
var kingPenguin = new Penguin();
baldEagle.useWings(); // "Flying! Barely flapping!"
kingPenguin.useWings(); // "Diving!"

### Constructors

- Constructors allow creating instances of built-in native objects appended with the keyword new
new Date();
Some don't use new such as Math();
new Math() -> Throws Uncaught TypeError: Math is not a Constructors
**Math() doesn't need to be instantiated, nor does it need to hold any data, it performs its methods when needed statically.

Same goes true for String, Number, and Boolean:

let apple = new String("apple");          let crow = "crow"
apple; // --> String {"apple"}            crow; // "crow"

apple is of object type String, crow here is a primitive value of a string literal

Instead of new Object, you should stick to the object literal syntax: {}.

A RegExp object is another built-in object in JavaScript. It's used to pattern-match strings using what's known as "Regular Expressions". Regular Expressions exist in many languages, not just JavaScript.

In JavaScript, you can build an instance of the RegExp constructor using new RegExp(). 

Alternatively, you can use a pattern literal instead of RegExp. Here's an example of using /d/ as a pattern literal, passed-in as an argument to the match method on a string.
"abcd".match(/d/); // ['d', index: 3, input: 'abcd', groups: undefined]
"abcd".match(/a/); // ['a', index: 0, input: 'abcd', groups: undefined]

other common constructor examples: new Date();
new Error();
new Map();
new Promise();
new Set();
new WeakSet();
new WeakMap();

### Creating classes

keyword class className {
  constructor(parameters that need storage) {

  }
}

class Train {
  constructor(color, lightsOn) {
      this.color = color;
      this.lightsOn = lightsOn;
  }
}

var myFirstTrain = new Train('red', false);

You can also add methods to classes and they will be shared with all future instance objects of said class:
class Train {
  constructor(color, lightsOn) {
    this.color = color;
    this.lightsOn = lightsOn;
  }
  toggleLights() {
    this.lightsOn = !this.lightsOn;
  }
  lightsStatus() {
    console.log('Lights on?', this.lightsOn);
  }
  getSelf() {
    console.log(this);
  }
  getPrototype() {
    var proto = Object.getPrototypeOf(this);
    console.log(proto);
  }
}

var trainEx = new Train('red', false);
train4.toggleLights(); // undefined
train4.lightsStatus(); // Lights on? true
train4.getSelf(); // Train {color: 'red', lightsOn: true}
train4.getPrototype(); // {constructor: f, toggleLights: f, lightsStatus: f, getSelf: f, getPrototype: f}

But! You can also implement polymorphism by inheriting base class and overriding inherited behavior. 

class HighSpeedTrain extends Train {
  constructor(passengers, highSpeedOn, color, lightsOn) {
    super(color, lightsOn);
    this.passengers = passengers;
    this.highSpeedOn = highSpeedOn;
  }
  toggleHighSpeed() {
    this.highSpeedOn = !this.highSpeedOn;
    console.log('High speed status:', this.highSpeedOn);
  }
  // And here is overriding
  toggleLights() {
    super.toggleLights();
    super.lightsStatus();
    console.log('Lights are 100% operational.');
  }
}

### Default parameters
- Useful ES6 Feature allows setting default params inside function definitions.
Ex:
function noDefaultParams(number) {
  console.log('Result: '. number*number)
}
noDefaultParams(); //Result: NaN

function withDefaultParams(number=10) {
  console.log('Result: '. number*number)
}

withDefaultParams(); // 'Result: 100'

lass NoDefaultParams {
    constructor(num1, num2, num3, string1, bool1) {
        this.num1 = num1;
        this.num2 = num2;
        this.num3 = num3;
        this.string1 = string1;
        this.bool1 = bool1;
    }
    calculate() {
        if(this.bool1) {
            console.log(this.string1, this.num1 + this.num2 + this.num3);
            return;
        }
        return "The value of bool1 is incorrect"
    }
}

^^ This requires careful parameters to work properly, but by adding in default parameters for string1 and bool1, this can improve the developer experience. Kind of like Excel functions that have optional inputs.

class WithDefaultParams {
    constructor(num1 = 1, num2 = 2, num3 = 3, string1 = "Result:", bool1 = true) {
        this.num1 = num1;
        this.num2 = num2;
        this.num3 = num3;
        this.string1 = string1;
        this.bool1 = bool1;
    }
    calculate() {
        if(this.bool1) {
            console.log(this.string1, this.num1 + this.num2 + this.num3);
            return;
        }
        return "The value of bool1 is incorrect"
    }
}
var better = new WithDefaultParams();
better.calculate(); // Result: 6

### Designing an OO Program:
Let's say we are building a program, we have to first know what objects we are dealing with. Let's make an OO Program with Animals.
Hierarchy: 
                      Animal
                   /          \
               Cat          Bird
          /         \          \
    HouseCat          Tiger      Parrot

class Animal {

}

class Cat extends Animal {

}

class Bird extends Animal {

}

and so on...

### Formatting text

- Destructuring -> Copying an item which becomes independent of an original (like extracting a folder into a copy)

Example: 

let {PI} = Math; // 3.1415926535...
let {pi} = Math; // undefined

PI === Math.PI; //true
PI = 1;
PI === Math.PI // false

### For of
Important to note objects are NOT iterable. 
const car = {
  speed: 100;
  color: 'blue';
}
for(prop of car) {
  console.log(prop);
}
// ^ returns TypeError: car is not iterable

const colors = ['red', 'blue', 'white'];
for (var color of colors) {
  console.log(color);
}
// red
// orange
// yellow

Object.keys(), Object.values(), Object.entries()
console.log(Object.keys(car)); // ['speed', 'color']
console.log(Object.entries(car)); // [ ['speed', 100], ['color', 'blue'] ]

Iterating over objects looks like: 
var clothingItem = {
    price: 50,
    color: 'beige',
    material: 'cotton',
    season: 'autumn'
}

for( const key of Object.keys(clothingItem) ) {
    console.log(key, ":", clothingItem[key])
}
console: 
price : 50
color : beige
material : cotton
season : autumn

### Data Structures

## Arrays: 
forEach(), filter(), map()
forEach() iterates over an array at an index. Syntax generally is forEach(arrayName, optional index)

Examples:
const fruits = ['kiwi','mango','apple','pear'];
function appendIndex(fruit, index) {
    console.log(`${index}. ${fruit}`)
}
fruits.forEach(appendIndex);

OR more directly:

const veggies = ['onion', 'garlic', 'potato'];
veggies.forEach( function(veggie, index) {
    console.log(`${index}. ${veggie}`);
});

filter() -> returns items in array based on a test
const nums = [1, 2, 3, 10, 20];
nums.filter( function(num) {
  return num > 9;
  console.log(result)
})
// [10, 20]

map() -> maps each array item to another array.

const nums = [10,20,30,40,50];
nums.map(function(num) {
  return num/10
});
// [1,2,3,4,5]

## Map
new Map();
let bestBoxers = new Map();
bestBoxers.set(1, "The Champion");
bestBoxers.set(2, "The Runner-up");
bestBoxers.set(3, "The third place");

console.log(bestBoxers); // Map(3) {1 => 'The Champion', 2 => 'The Runner-up', 3 => 'The third place'}

bestBoxers.get(1); // 'The Champion'

## Set
new Set(); //UNIQUE VALUES only
const repetitiveNums = [0,0,0,1,1,1,2,2,2,3,3,3];
const uniqueNums = new Set(repetitiveNums);
console.log(uniqueNums); // {0, 1, 2, 3}

Other data structures in JavaScript
Besides the built-in data structures in JavaScript, it's possible to build non-native, custom data structures. These data structures come built-in natively in some other programming languages. 

Some more advanced data structures that have not been covered include: 

Queues 

Linked lists (singly-linked and doubly-linked) 

Trees 

Graphs  

### Using Spread and Rest Operators
- Spread operator -> Add new members without using push()
  - Convert string to array
  - Copy either object or array into a separate object
- Rest operator -> Can gather multiple elements int oa single array or object. Useful for handling remaining items in Destructuring or collecting arguments in functions.

const [first, ...rest] = [1, 2, 3, 4]
console.log(rest); // [2,3,4]

or

function sum(...numbers) {
  return numbers.reduce((total,num) => total + num, 0_;)
}
console.log(sum(1,2,3)); // 6

- Spread operators expand arrays, objects, or strings and is used for concatenation, copying or passing arguments
- Rest operators gather elements into a single array or object
- Used in Destructuring or collecting arguments

* Adding without push()
let fruits = ['apple', 'banana'];
fruits = [...fruits, 'pear'];

* String to array
const greeting = 'hello';
const arrOfChars = [...greeting]

* Copying object into separate Object
const car1 = {
    speed: 200,
    color: 'yellow'
}
const car2 = {...car1};

### DOM
- DOM Tree Structure -> HTML file is mapped out in tree structure with nested objects for different parts of the page.
- DOM -> Browsers build DOM or Model for every webpage when downloading as a JS Object

### Moving Data Around the Web Reading
- Data is currently being sent across millions of websites for free or paid. This process of sending and receiving data requires a standardized format.
- Around 2001, Douglas Crockford came up with a data interchange format based on JS Objects, he called it JSON!
- Before JSON was XML (Extensible Markup Language), but it required more characters than the data it was sending, and it was not very interoperable with JS.
- JSON dominates because it is essentially a stringified JS object and is lightweight, AND it is easily handled by JS because it is essentially JS. 
* All JSON is JavaScript, but not all JavaScript is JSON.
- Only a subset of values in JavaScript can be properly stringified to JSON and parsed from a JavaScript object into a JSON string.
  - primitive values: strings, numbers, booleans, null
  - complex values: objects and arrays (no functions!)
  - Objects have double-quoted strings for all keys
  - Properties are comma-delimited both in JSON objects and in JSON arrays, just like in regular JavaScript code
  - String properties must be surrounded in double quotes.

  ### Other JS Environments
  - At first, JS was a front end only language until 2009, dev Ryan Dao decided to use Google's V8 JS Engine and make it work on the server. This created Node.js
  - Node.js is a stand-alone environment, and can run in multiple settings like a CMD line, desktop app or web backend. 
  - Node.js has NPM package manager which allows devs to use libraries and frameworks as Node modules.
  - after starting a node project, it creates a package.json which holds instructions on all modules. There are around 11 million modules in Node including react, webpack, angular core 


  ### Testing
  - Types of testing: E2E, Integration, Unit 
    -E2E -> imitates how a user interacts with the app. Take the longest to make and run (WebDriverJS, Cypress, Protractor)
    -Integration -> Testing how separate parts of apps work together. 
    -Unit -> Testing smallest parts of code in isolation
          -> Self-contained, fast to write and run

  Introduction to Jest (See JS Files)
- Jasmine, Mocha, qUnit, Karma are other JS testing libraries 
- Jest supports code coverage
- Mocking allows separating code from dependencies.
  - Example: You are a frontend dev, and you finished your feature before the backend finished theirs. Instead of waiting, you can mock a backend dataflow that actually comes from the client
  - Snapshot testing verifies there are no regressions in DOM after code changes 

  